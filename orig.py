# -*- generated by 1.0.12 -*-
import da
PatternExpr_373 = da.pat.TuplePattern([da.pat.ConstantPattern('CAPTURE'), da.pat.FreePattern(None), da.pat.FreePattern(None), da.pat.FreePattern(None)])
PatternExpr_473 = da.pat.TuplePattern([])
PatternExpr_543 = da.pat.TuplePattern([da.pat.ConstantPattern('CAPTURE'), da.pat.FreePattern('ph'), da.pat.FreePattern('l'), da.pat.FreePattern('i')])
PatternExpr_554 = da.pat.FreePattern('node')
PatternExpr_722 = da.pat.TuplePattern([da.pat.ConstantPattern('ACCEPT'), da.pat.FreePattern('ph'), da.pat.FreePattern('l')])
PatternExpr_731 = da.pat.FreePattern('node')
PatternExpr_808 = da.pat.TuplePattern([da.pat.ConstantPattern('ACK'), da.pat.FreePattern('i')])
PatternExpr_815 = da.pat.FreePattern('node')
PatternExpr_849 = da.pat.TuplePattern([da.pat.ConstantPattern('ELECTED'), da.pat.FreePattern('i')])
PatternExpr_856 = da.pat.FreePattern('node')
PatternExpr_885 = da.pat.TuplePattern([da.pat.ConstantPattern('INFORM'), da.pat.FreePattern('x')])
PatternExpr_892 = da.pat.FreePattern('node')
PatternExpr_935 = da.pat.TuplePattern([da.pat.ConstantPattern('OWNER'), da.pat.FreePattern('i')])
PatternExpr_942 = da.pat.FreePattern('node')
_config_object = {}
import sys
import math

class P(da.DistProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._PReceivedEvent_0 = []
        self._PReceivedEvent_1 = []
        self._events.extend([da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_0', PatternExpr_373, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_1', PatternExpr_473, sources=None, destinations=None, timestamps=None, record_history=True, handlers=[]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_2', PatternExpr_543, sources=[PatternExpr_554], destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_542]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_3', PatternExpr_722, sources=[PatternExpr_731], destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_721]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_4', PatternExpr_808, sources=[PatternExpr_815], destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_807]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_5', PatternExpr_849, sources=[PatternExpr_856], destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_848]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_6', PatternExpr_885, sources=[PatternExpr_892], destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_884]), da.pat.EventPattern(da.pat.ReceivedEvent, '_PReceivedEvent_7', PatternExpr_935, sources=[PatternExpr_942], destinations=None, timestamps=None, record_history=None, handlers=[self._P_handler_934])])

    def setup(self, hCycle, **rest_1065):
        super().setup(hCycle=hCycle, **rest_1065)
        self._state.hCycle = hCycle
        self._state.n = len(self._state.hCycle)
        self._state.k = (self._state.n / (2 ** math.ceil(math.log(math.log(self._state.n, 2), 2))))
        self._state.state = 'candidate'
        self._state.level = 0
        self._state.phase = 1
        self._state.owner = 0
        self._state.ring = [self._state.hCycle[int(((i * self._state.k) % self._state.n))] for i in range(int((self._state.n / self._state.k)))]
        self._state.step = 0
        self._state.elected = False
        self._state.Received = False
        self._state.Response = 0
        self._state.done = False
        self._state.first_msg = True
        self._state.leaderid = None

    def run(self):
        self.output('n = ', self._state.n)
        self.output('k = ', self._state.k)
        if (self._state.state == 'candidate'):
            self.output('be candidate')
            self.candidateAct()
        if ((self._state.state == 'captured') and (self._state.leaderid == None)):
            self.output('be captured')
            self.capturedAct()
        self.output('Leader is', self._state.leaderid)

    def candidateAct(self):
        while ((self._state.state == 'candidate') and (self._state.phase == 1)):
            self.output(self._state.level)
            if (self._state.level >= (self._state.n / self._state.k)):
                self.send(('OWNER', self._id), to=self._state.ring)
                self.output('send OWNER to ', self._state.ring)
                self._state.Response = 0
            else:
                send_to = int((((self._state.level + 1) * self._state.k) % self._state.n))
                self.send(('CAPTURE', 1, self._state.level, self._id), to=self._state.hCycle[send_to])
                self.output('send CAPTURE to ', self._state.hCycle[int((((self._state.level + 1) * self._state.k) % self._state.n))])
            self._state.Received = False
            while ((self._state.state == 'candidate') and (self._state.phase == 1) and (self._state.Received == False)):
                super()._label('_st_label_370', block=False)

                def ExistentialOpExpr_371():
                    for (_, _, (_ConstantPattern389_, _, _, _)) in self._PReceivedEvent_0:
                        if (_ConstantPattern389_ == 'CAPTURE'):
                            if True:
                                return True
                    return False
                _st_label_370 = 0
                while (_st_label_370 == 0):
                    _st_label_370 += 1
                    if ExistentialOpExpr_371():
                        _st_label_370 += 1
                    else:
                        super()._label('_st_label_370', block=True)
                        _st_label_370 -= 1
                else:
                    if (_st_label_370 != 2):
                        continue
                if (_st_label_370 != 2):
                    break
                self.output('wait finish')
        if ((self._state.state == 'candidate') and (self._state.phase == 2)):
            self._state.step = 0
            self._state.elected = False
            while ((self._state.state == 'candidate') and (self._state.elected == False)):
                self.send(('CAPTURE', 2, self._state.step, self._id), to=[self._state.hCycle[int((((i * self._state.k) / (2 ^ self._state.step)) % self._state.n))] for i in range(0, int((2 ** self._state.step)))])
                self._state.Received = False
                self._state.Response = 0
                while ((self._state.state == 'candidate') and (self._state.elected == False) and (self._state.Received == False)):
                    super()._label('_st_label_470', block=False)

                    def ExistentialOpExpr_471():
                        for _ in self._PReceivedEvent_1:
                            if True:
                                return True
                        return False
                    _st_label_470 = 0
                    while (_st_label_470 == 0):
                        _st_label_470 += 1
                        if ExistentialOpExpr_471():
                            _st_label_470 += 1
                        else:
                            super()._label('_st_label_470', block=True)
                            _st_label_470 -= 1
                    else:
                        if (_st_label_470 != 2):
                            continue
                    if (_st_label_470 != 2):
                        break
            self.send(('ELECTED', self._id), to=self._state.hCycle)
            self._state.leaderid = self._id

    def capturedAct(self):
        self._state.done = False
        self._state.first_msg = True
        while (self._state.done == False):
            if (self._state.first_msg == True):
                self._state.state = 'captured'
                self._state.owner = 0
                self._state.phase = 1
            super()._label('_st_label_521', block=False)

            def ExistentialOpExpr_522():
                for _ in self._PReceivedEvent_1:
                    if True:
                        return True
                return False
            _st_label_521 = 0
            while (_st_label_521 == 0):
                _st_label_521 += 1
                if ExistentialOpExpr_522():
                    _st_label_521 += 1
                else:
                    super()._label('_st_label_521', block=True)
                    _st_label_521 -= 1
            else:
                if (_st_label_521 != 2):
                    continue
            if (_st_label_521 != 2):
                break
            self._state.first_msg = False

    def _P_handler_542(self, ph, l, i, node):
        self.output('received CAPTURE(', ph, l, i, ')', self._state.state, self._state.phase)
        if (self._state.state == 'candidate'):
            if (self._state.phase == 1):
                if (ph == 1):
                    if ((self._state.level < l) or ((self._state.level == l) and (self._id < i))):
                        self.send(('ACCEPT', 1, self._state.level), to=node)
                        self._state.state = 'captured'
                    elif ((self._state.level == l) and (self._id == i)):
                        self.send(('ACCEPT', 1, self._state.level), to=node)
                elif (ph == 2):
                    self._state.state = 'captured'
                    self._state.phase = 2
                    self.send(('ACCEPT', 2, 0), to=node)
            elif (self._state.phase == 2):
                if (ph == 2):
                    if ((self._state.level > l) or ((self._state.level == l) and (self._id > i))):
                        self.send(('ACCEPT', 2, 0), to=node)
                        self._state.state = 'captured'
                    elif ((self._state.level == l) and (self._id == i)):
                        self.send(('ACCEPT', 2, 0), to=node)
        elif (self._state.state == 'captured'):
            if (ph == 1):
                if (self._state.phase == 1):
                    self.send(('ACCEPT', 1, 0), to=node)
            elif (ph == 2):
                if ((self._state.phase == 1) or (self._state.owner == 0)):
                    self.send(('ACCEPT', 2, 0), to=node)
                else:
                    self.send(('INFORM', self._state.owner), to=node)
    _P_handler_542._labels = None
    _P_handler_542._notlabels = None

    def _P_handler_721(self, ph, l, node):
        self.output('received ACCEPT (', ph, l, node, ')', self._state.state, self._state.phase)
        if (self._state.state == 'candidate'):
            if ((self._state.phase == 1) and (ph == 1)):
                self._state.level = ((self._state.level + l) + 1)
                self._state.Received = True
            elif ((self._state.phase == 2) and (ph == 2)):
                self._state.Response = (self._state.Response + 1)
                if (self._state.Response == (2 ^ (self._state.step - 1))):
                    self._state.step = (self._state.step + 1)
                if (self._state.step == (math.log(self._state.k, 2) + 1)):
                    self._state.elected = True
                else:
                    self._state.Received = True
    _P_handler_721._labels = None
    _P_handler_721._notlabels = None

    def _P_handler_807(self, i, node):
        self.output('received ACK ', self._state.state, self._state.phase)
        if ((self._state.state == 'candidate') and (self._state.phase == 1) and (i == self._id)):
            self._state.Response += 1
            if (self._state.Response == ((self._state.n / self._state.k) - 1)):
                self._state.phase = 2
    _P_handler_807._labels = None
    _P_handler_807._notlabels = None

    def _P_handler_848(self, i, node):
        self.output('received ELECTED ', self._state.state, self._state.phase)
        if (self._state.state == 'candidate'):
            self._state.state = 'captured'
            self._state.leaderid = i
        elif (self._state.state == 'captured'):
            self._state.done = True
            self._state.leaderid = i
    _P_handler_848._labels = None
    _P_handler_848._notlabels = None

    def _P_handler_884(self, x, node):
        self.output('received INFORM ', self._state.state, self._state.phase)
        if ((self._state.state == 'candidate') and (self._state.phase == 2)):
            self._state.state = 'captured'
            e = self._state.hCycle.index(node)
            self.send(('CAPTURE', 2, self._state.step, self._id), to=self._state.hCycle[int(((e + x) % self._state.n))])
    _P_handler_884._labels = None
    _P_handler_884._notlabels = None

    def _P_handler_934(self, i, node):
        self.output('received OWNER ', self._state.state, self._state.phase)
        if ((self._state.state == 'captured') and (self._state.phase == 1)):
            self._state.owner = i
            self._state.phase = 2
            self.send(('ACK', i), to=node)
    _P_handler_934._labels = None
    _P_handler_934._notlabels = None

class Node_(da.NodeProcess):

    def __init__(self, procimpl, props):
        super().__init__(procimpl, props)
        self._events.extend([])
    _config_object = {'channel': 'fifo'}

    def run(self):
        n = (int(sys.argv[1]) if (len(sys.argv) > 1) else 16)
        ps = list(self.new(P, num=n))
        for (i, p) in enumerate(ps):
            self._setup({p}, ([ps[int(((i + j) % n))] for j in range(n)],))
        self._start(ps)
