import time
import sys
import math
import random
import time

class P(process):
    def setup(hCycle:list):
        self.n = len(hCycle)    # number of precessors
        self.m = int(2 ** math.floor(math.log(n, 2)))    # if n is not power of 2
        self.k = m / (2 ** math.ceil(math.log(math.log(m, 2), 2)))
        self.state = 'candidate'    # state of p_i: candidate / captured / leader
        self.level = 0    # number of nodes p_i captured in 1st phase
        self.phase = 1    # phase number: 1 / 2
        self.owner = 0    # edge leading to 1st phase winner
        self.ring = [hCycle[int((i * k) % n)] for i in range(int(math.ceil(n / k)))]    # list of processor in R_i
        self.OriRingLen = len(ring)
        self.ringPh2 = []
        
        self.step = 0
        #self.elected = False
        self.Received = False
        self.Response = 0
        self.done = False
        self.first_msg = True
        self.leaderid = None
        self.receiving_flag = False
        self.decided = 0
        self.wake_rate = 0.8
        self.awaken = random.random()

        self.waitTime = 0.1

        # if n is not power of 2
        if (m != n):
            for i in range(-int(math.ceil(n / k)) + 1, 0, 1):
                index = int((i * k) % n)
                if hCycle[index] not in ring:
                    ring.append(hCycle[index])


    def candidateAct():
        while (state == 'candidate' and phase == 1):
            # output("level = ", level)
            if level >= len(ring):
                send(('OWNER', self), to=ring)# - [self])
                # output("send OWNER to ", ring)
                # output("ring lenth =  ", len(ring))
                Response = 0;
            else:
                send(('CAPTURE', 1, level, self), to= ring[int((level + 1) % len(ring))])
                # output("send CAPTURE to ", ring[int((level + 1) % len(ring))])

            Received = False
            while (state == 'candidate' and phase == 1 and Received == False):
                await(receiving_flag)
                receiving_flag = False
                # output("wait finish", phase)

        if (state == 'candidate' and phase == 2):
            step = 1

            while (state == 'candidate'):
                ringPh2 = []
                for i in range(1 , int((2 ** (step-1))+1)):
                    index = int(((i * k) / (2 ** step)) % n)
                    if hCycle[index] not in ring:
                        ringPh2.append(hCycle[index])
                
                # if n is not power of 2
                if (n != m):
                    for i in range(- int((2 ** (step-1))+1) + 1, 0, 1):
                        index = int(((i * k) / (2 ** step)) % n)
                        if hCycle[index] not in (ring + ringPh2):
                            ringPh2.append(hCycle[index])
                
               
                send(('CAPTURE', 2, step, self), to=ringPh2)
                # output("step = ", step)
                # output("send CAPTURE to", ringPh2)
                Received = False
                Response = 0
                while (state == 'candidate' and Received == False):
                    if (len(ringPh2) == 0):
                        step = step + 1
                        if step >= math.log(k, 2) + 1:
                            #elected = True
                            self.state = 'leader'
                            # output("elected")
                        break
                    await(receiving_flag)
                    receiving_flag = False
            if state == 'leader':
                send(('ELECTED', self), to=hCycle)# - [self])
                # output('ELECTED', state)
                leaderid = self

    def capturedAct():
        done = False
        first_msg = True
        while done == False:
            if first_msg == True:
                state = 'captured'
                owner = 0
                phase = 1
            await(receiving_flag)
            receiving_flag = False
            first_msg = False

    # CAPURE(phase, level/step, id)
    def receive(msg=('CAPTURE', ph, l, node), from_ = sender):
        stall()
        receiving_flag = True
        # output("received CAPTURE(" ,ph, l, node, ")", state, phase)
        if state == 'candidate':
            if phase == 1:
                if ph == 1:
                    if (level < l or (level == l and self < node)):
                        send(('ACCEPT', 1, level), to=sender)
                        # output("send ACCEPT (", 1, level, sender, ")")
                        state = 'captured'
                    elif (self == node):
                        send(('ACCEPT', 1, 0), to=sender)
                        # output("send ACCEPT (", 1, 0, sender, ")")
                elif ph == 2:
                    state = 'captured'
                    phase = 2
                    send(('ACCEPT', 2, 0), to=sender)
                    # output("send ACCEPT to (", sender, ")", 2, 0)
            elif phase == 2:
                if ph == 2:
                    if (l > step or (l == step and  node > self)):
                        send(('ACCEPT', 2, 0), to=sender)
                        # output("send ACCEPT (", 2, 0, sender, ")")
                        state = 'captured'
                    elif (l == step and self == node):
                        send(('ACCEPT', 2, 0), to=sender)
                        # output("send ACCEPT (", 2, 0, sender, ")")
        elif state == 'captured':
            if ph == 1:
                if phase == 1:
                    send(('ACCEPT', 1, 0), to=sender)
                    # output("send ACCEPT (", 1, 0, sender, ")")
            elif ph == 2:
                if (phase == 1 or owner == 0):
                    send(('ACCEPT', 2, 0), to=sender)
                    phase = 2
                else:
                    send(('INFORM', owner), to=sender)
                    # output("send INFORM(", owner, ") to", sender, state)

    # ACCEPT(phase, level)
    def receive(msg=('ACCEPT', ph, l), from_= sender):
        stall()
        receiving_flag = True
        # output("received ACCEPT from (", ph, l, sender, ")" , state, phase)
        if state == 'candidate':
            if (phase == 1 and ph ==1):
                addUp = level + l + 1
                if (level <= (OriRingLen - 2) and addUp > (OriRingLen - 2) ):    # split ring and ringBelong
                    level = OriRingLen - 1
                else:
                    level = addUp
                Received = True
            elif (phase == 2 and ph == 2):
                Response = Response + 1
                # output("Response = ", Response)
                if Response >= len(ringPh2):
                    step = step + 1
                    # output("step = ", step)
                    if step >= math.log(k, 2) + 1:
                        #elected = True
                        self.state = 'leader'
                        # output("elected")
                    else:
                        Received = True

    # ACK(id)
    def receive(msg=('ACK', node), from_= sender):
        stall()
        receiving_flag = True
        # output("received ACK from", sender, ")" , state, phase)
        if (state == 'candidate' and phase == 1 and node == self):
            Response = Response + 1
            # output("Response = ", Response)
            if (Response >= len(ring) - 1):
                phase = 2
                # output("go to phase 2")

    # ELECTED(id)
    def receive(msg=('ELECTED', node), from_= sender):
        stall()
        receiving_flag = True
        # output("received ELECTED " , state, phase)
        if state == 'candidate':
            state = 'captured'
            leaderid = node

        elif (state == 'captured'):
            done = True
            leaderid = node

    # INFORM(x)
    def receive(msg=('INFORM', x), from_= sender):
        stall()
        receiving_flag = True
        # output("received INFORM (", x, ")" "from", sender, ")", state, phase)
        if (state == 'candidate' and phase == 2):
            e = hCycle.index(sender)
            send(('CAPTURE', 2, step, self), to=hCycle[int((e + x) % n)])
            # output("send CAPTURE to(", hCycle[int((e + x) % n)], ")", 2, step)

    # OWNER(x)
    def receive(msg=('OWNER', node), from_= sender):
        stall()
        receiving_flag = True
        # output("received OWNER " , state, phase)
        if (state == "captured" and phase == 1):
            owner = hCycle.index(node)
            phase = 2
            send(('ACK', node), to=sender)
            # output("send ACK to ", sender)
        elif (state == 'candidate' and phase == 1 and self == node):
            owner = hCycle.index(node)
            send(('ACK', node), to=sender)

    def stall():
        if await(False): pass
        elif timeout(waitTime): pass

    def run():
        # output("n = ", n)
        # output("m = ", m)
        # output("k = ", k)

        # 20% processors don't wake spontaneously, but wake to receiving messages
        
        if (awaken > wake_rate):
            state == 'captured'
            # output("didn't awaken")

        if state == 'candidate':
            # output("be candidate")
            candidateAct()
        
        if (state == 'captured' and leaderid == None):
            # output("be captured")
            capturedAct()

        #output("Leader is", leaderid)
        output(time.clock())

def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 16
    config(channel="fifo")
    ps = list(new(P, num= n))
    # output(ps)
    for i, p in enumerate(ps):
        setup({p}, ([ps[int((i+j) % n)] for j in range(n)],))
    # output('start finish')
    output(time.clock())
    start(ps)



