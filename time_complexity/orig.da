import sys
import math
import random
import time

class P(process):
    def setup(hCycle:list):
        self.n = len(hCycle)    # number of precessors
        self.m = int(2 ** math.floor(math.log(n, 2)))    # if n is not power of 2
        self.k = m / (2 ** math.ceil(math.log(math.log(m, 2), 2)))
        self.state = 'candidate'    # state of p_i: candidate / captured / leader
        self.level = 0    # number of nodes p_i captured in 1st phase
        self.phase = 1    # phase number: 1 / 2
        self.owner = 0    # edge leading to 1st phase winner
        self.ring = [hCycle[int((i * k) % n)] for i in range(int(math.ceil(n / k)))]    # list of processor in R_i
        self.ringPh2 = []
        
        self.step = 0
        #self.elected = False
        self.Received = False
        self.Response = 0
        self.done = False
        self.first_msg = True
        self.leaderid = None
        self.receiving_flag = False
        self.decided = 0
        self.wake_rate = 0.8
        self.awaken = random.random()
        
        self.waitTime = 0.5

        # if n is not power of 2
        if (m != n):
            for i in range(1, int(math.ceil(n / k))):
                index = - int((i * k) % n)
                if hCycle[index] not in ring:
                    ring.append(hCycle[index])


    def candidateAct():
        while (state == 'candidate' and phase == 1):
            #output("level = ", level)
            if level >= len(ring):
                send(('OWNER', self), to=ring)# - [self])
                #output("send OWNER to ", ring)
                #output("ring lenth =  ", len(ring))
                Response = 0;
            else:
                # send_to = int(((level + 1) * k) % n)
                #if ((send_to % n )!= 0):
                # send(('CAPTURE', 1, level, self), to= hCycle[send_to])
                # output("send CAPTURE to ", hCycle[int(((level + 1) * k) % n)])
                send(('CAPTURE', 1, level, self), to= ring[int((level + 1) % len(ring))])
                #output("send CAPTURE to ", ring[level])

            Received = False
            while (state == 'candidate' and phase == 1 and Received == False):
                #await (received(()))
                #await (some(received(("CAPTURE", _, _, _))))
                await(receiving_flag)
                receiving_flag = False
                #output("wait finish", phase)

        if (state == 'candidate' and phase == 2):
            step = 1
            #elected = False
            # if (len(ring) == n):
            #     state = 'leader'
            #     output('leader because phase 1')
            while (state == 'candidate'):
                ringPh2 = []
                for i in range(1 , int((2 ** (step-1))+1)):
                    index = int(((i * k) / (2 ** step)) % n)
                    if hCycle[index] not in ring:
                        ringPh2.append(hCycle[index])
                
                # if n is not power of 2
                if (n != m):
                    for i in range(1, int((2 ** (step-1))+1)):
                        index = - int(((i * k) / (2 ** step)) % n)
                        if hCycle[index] not in (ring + ringPh2):
                            ringPh2.append(hCycle[index])
                
                # maybe already captured al nodes in phase 1
                # if (len(ringPh2) == 0):
                # 	output('leader because phase 1')
                # 	state = 'leader'
                # 	break
            	# ringPh2 = [hCycle[int(((i * k) / (2 ** step)) % n)] for i in range(1 , int((2 ** (step-1))+1)) if hCycle[int(((i * k) / (2 ** step)) % n)] not in ring]
            	# ringPh2 = ringPh2 + [hCycle[- int(((i * k) / (2 ** step)) % n)] for i in range(1, )]
                send(('CAPTURE', 2, step, self), to=ringPh2)
                # send(('CAPTURE', 2, step, self), to=[hCycle[int(((i * k) / (2 ** step)) % n)] for i in range(1 , int((2 ** (step-1))+1))])
                #output("step = ", step)
                #output("send CAPTURE to", ringPh2)
                #output("send CAPTURE to", [hCycle[int(((i * k) / (2 ** step)) % n)] for i in range(1 , int((2 ** (step-1))+1))])
                Received = False
                Response = 0
                # while (state == 'candidate' and elected == False and Received == False):
                while (state == 'candidate' and Received == False):
                    if (len(ringPh2) == 0):
                        step = step + 1
                        if step >= math.log(k, 2) + 1:
                        	#elected = True
                        	self.state = 'leader'
                        	#output("elected")
                        break
                    #await (received(()))
                    #await (some(received(())))
                    await(receiving_flag)
                    receiving_flag = False
            if state == 'leader':
                send(('ELECTED', self), to=hCycle)# - [self])
                #output('ELECTED', state)
                leaderid = self

    def capturedAct():
        done = False
        first_msg = True
        while done == False:
            if first_msg == True:
                state = 'captured'
                owner = 0
                phase = 1
            #await (received(()))
            #await (some(received(())))
            await(receiving_flag)
            receiving_flag = False
            first_msg = False

    # CAPURE(phase, level/step, id)
    def receive(msg=('CAPTURE', ph, l, node), from_ = sender):
        stall()
        receiving_flag = True
        #output("received CAPTURE(" ,ph, l, node, ")", state, phase)
        if state == 'candidate':
            if phase == 1:
                if ph == 1:
                    if (level < l or (level == l and self < node)):
                        send(('ACCEPT', 1, level), to=sender)
                        #output("send ACCEPT (", 1, level, sender, ")")
                        state = 'captured'
                    elif (self == node):
                        send(('ACCEPT', 1, level), to=sender)
                        #output("send ACCEPT (", 1, level, sender, ")")
                elif ph == 2:
                    state = 'captured'
                    phase = 2
                    send(('ACCEPT', 2, 0), to=sender)
                    #output("send ACCEPT to (", sender, ")", 2, 0)
            elif phase == 2:
                if ph == 2:
                    if (l > step or (l == step and  node > self)):
                        send(('ACCEPT', 2, 0), to=sender)
                        #output("send ACCEPT (", 2, 0, sender, ")")
                        state = 'captured'
                    elif (l == step and self == node):
                        send(('ACCEPT', 2, 0), to=sender)
                        #output("send ACCEPT (", 2, 0, sender, ")")
        elif state == 'captured':
            if ph == 1:
                if phase == 1:
                    send(('ACCEPT', 1, 0), to=sender)
                    #output("send ACCEPT (", 1, 0, sender, ")")
            elif ph == 2:
                if (phase == 1 or owner == 0):
                    send(('ACCEPT', 2, 0), to=sender)
                    phase = 2
                else:
                    send(('INFORM', owner), to=sender)
                    #output("send INFORM(", owner, ") to", sender, state)

    # ACCEPT(phase, level)
    def receive(msg=('ACCEPT', ph, l), from_= sender):
        stall()
        receiving_flag = True
        #output("received ACCEPT (", ph, l, sender, ")" , state, phase)
        if state == 'candidate':
            if (phase == 1 and ph ==1):
                level = level + l + 1
                Received = True
            elif (phase == 2 and ph == 2):
                Response = Response + 1
                #output("Response = ", Response)
                if Response >= len(ringPh2):
                    step = step + 1
                    #output("step = ", step)
                    if step >= math.log(k, 2) + 1:
                        #elected = True
                        self.state = 'leader'
                        #output("elected")
                    else:
                        Received = True

    # ACK(id)
    def receive(msg=('ACK', node), from_= sender):
        stall()
        receiving_flag = True
        #output("received ACK " , state, phase)
        if (state == 'candidate' and phase == 1 and node == self):
            Response = Response + 1
            #output("Response = ", Response)
            if (Response >= len(ring) - 1):
                phase = 2
                #output("go to phase 2")

    # ELECTED(id)
    def receive(msg=('ELECTED', node), from_= sender):
        stall()
        receiving_flag = True
        #output("received ELECTED " , state, phase)
        if state == 'candidate':
            state = 'captured'
            leaderid = node

        elif (state == 'captured'):
            done = True
            leaderid = node

    # INFORM(x)
    def receive(msg=('INFORM', x), from_= sender):
        stall()
        receiving_flag = True
        #output("received INFORM (", x, ")" "from", sender, ")", state, phase)
        if (state == 'candidate' and phase == 2):
            e = hCycle.index(sender)
            send(('CAPTURE', 2, step, self), to=hCycle[int((e + x) % n)])
            #output("send CAPTURE to(", hCycle[int((e + x) % n)], ")", 2, step)

    # OWNER(x)
    def receive(msg=('OWNER', node), from_= sender):
        stall()
        receiving_flag = True
        #output("received OWNER " , state, phase)
        if (state == 'captured' and phase == 1):
            owner = hCycle.index(node)
            phase = 2
            send(('ACK', node), to=sender)
        elif (state == 'candidate' and phase == 1 and self == node):
            owner = hCycle.index(node)
            send(('ACK', node), to=sender)

    def stall():
        if await(False): pass
        elif timeout(waitTime): pass

    def run():
        #output("time is", time.clock())
        #output("n = ", n)
        #output("m = ", m)
        #output("k = ", k)

        # wake_rate(20%) processors don't wake spontaneously, but wake to receiving messages
        if (awaken > wake_rate):
        	state == 'captured'
        	#output("didn't awaken")

        if state == 'candidate':
            #output("be candidate")
            candidateAct()
        
        if (state == 'captured' and leaderid == None):
            #output("be captured")
            capturedAct()

        #output("Leader is", leaderid)
        output(time.clock())
        #output("nMsg = ", nMsg)
        # if (leaderid != None):
        # 	DECIDENUM = DECIDENUM + 1
        # 	output(DECIDENUM)
        	


def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 16
    config(channel="fifo")
    ps = list(new(P, num= n))
	#output(ps)
    for i, p in enumerate(ps):
        setup({p}, ([ps[int((i+j) % n)] for j in range(n)],))
    output(time.clock())
    start(ps)
    # if await(False): pass
    # elif timeout(1): pass

	# await(DECIDENUM == n)
	# output("decided_num = ", DECIDENUM)
    # num_decided = 0
    # for p in ps:
    # 	num_decided += p.is_decided()
    # output(num_decided)
