import sys
import math

class P(process):
    def setup(hCycle:list):
        self.n = len(hCycle)    # number of precessors
        self.k = n / (2 ** math.ceil(math.log(math.log(n, 2), 2)))
        self.state = 'candidate'    # state of p_i: candidate / captured / elected
        self.level = 0    # number of nodes p_i captured in 1st phase
        self.phase = 1    # phase number: 1 / 2
        self.owner = 0    # edge leading to 1st phase winner
        self.ring = [hCycle[int((i * k) % n)] for i in range(int(n / k))]    # list of processor in R_i
        
        self.step = 0
        self.elected = False
        self.Received = False
        self.Response = 0
        self.done = False
        self.first_msg = True
        self.leaderid = None
        self.receiving_flag = False


    def candidateAct():
        while (state == 'candidate' and phase == 1):
            #output("level = ", level)
            if level >= (n / k):
                send(('OWNER', self), to=ring)# - [self])
                #output("send OWNER to ", ring)
                Response = 0;
            else:
                send_to = int(((level + 1) * k) % n)
                #if ((send_to % n )!= 0):
                send(('CAPTURE', 1, level, self), to= hCycle[send_to])
                #output("send CAPTURE to ", hCycle[int(((level + 1) * k) % n)])
            Received = False

            while (state == 'candidate' and phase == 1 and Received == False):
                #await (received(()))
                #await (some(received(("CAPTURE", _, _, _))))
                await(receiving_flag)
                receiving_flag = False
                #output("wait finish", phase)

        if (state == 'candidate' and phase == 2):
            step = 1
            elected = False
            while (state == 'candidate' and elected == False):
                send(('CAPTURE', 2, step, self), to=[hCycle[int(((i * k) / (2 ** step)) % n)] for i in range(1 , int((2 ** (step-1))+1))])
                #output("step = ", step)
                #output("send CAPTURE to", [hCycle[int(((i * k) / (2 ** step)) % n)] for i in range(1 , int((2 ** (step-1))+1))])
                Received = False
                Response = 0
                while (state == 'candidate' and elected == False and Received == False):
                    #await (received(()))
                    #await (some(received(())))
                    await(receiving_flag)
                    receiving_flag = False
            if state == 'candidate':
                send(('ELECTED', self), to=hCycle)# - [self])
                #output('ELECTED', state)
                leaderid = self

    def capturedAct():
        done = False
        first_msg = True
        while done == False:
            if first_msg == True:
                state = 'captured'
                owner = 0
                phase = 1
            #await (received(()))
            #await (some(received(())))
            await(receiving_flag)
            receiving_flag = False
            first_msg = False

    # CAPURE(phase, level/step, id)
    def receive(msg=('CAPTURE', ph, l, node), from_ = sender):
        receiving_flag = True
        #output("received CAPTURE(" ,ph, l, node, ")", state, phase)
        if state == 'candidate':
            if phase == 1:
                if ph == 1:
                    if (level < l or (level == l and self < node)):
                        send(('ACCEPT', 1, level), to=sender)
                        #output("send ACCEPT (", 1, level, sender, ")")
                        state = 'captured'
                    elif (level == l and self == node):
                        send(('ACCEPT', 1, level), to=sender)
                        #output("send ACCEPT (", 1, level, sender, ")")
                elif ph == 2:
                    state = 'captured'
                    phase = 2
                    send(('ACCEPT', 2, 0), to=sender)
                    #output("send ACCEPT to (", sender, ")", 2, 0)
            elif phase == 2:
                if ph == 2:
                    if (l > step or (l == step and  node > self)):
                        send(('ACCEPT', 2, 0), to=sender)
                        #output("send ACCEPT (", 2, 0, sender, ")")
                        state = 'captured'
                    elif (l == step and self == node):
                        send(('ACCEPT', 2, 0), to=sender)
                        #output("send ACCEPT (", 2, 0, sender, ")")
        elif state == 'captured':
            if ph == 1:
                if phase == 1:
                    send(('ACCEPT', 1, 0), to=sender)
                    #output("send ACCEPT (", 1, 0, sender, ")")
            elif ph == 2:
                if (phase == 1 or owner == 0):
                    send(('ACCEPT', 2, 0), to=sender)
                    phase = 2
                else:
                    send(('INFORM', owner), to=sender)
                    #output("send INFORM(", owner, ") to", sender, state)

    # ACCEPT(phase, level)
    def receive(msg=('ACCEPT', ph, l), from_= sender):
        receiving_flag = True
        #output("received ACCEPT (", ph, l, sender, ")" , state, phase)
        if state == 'candidate':
            if (phase == 1 and ph ==1):
                level = level + l + 1
                Received = True
            elif (phase == 2 and ph == 2):
                Response = Response + 1
                #output("Response = ", Response)
                if Response == 2 ** (step - 1):
                    step = step + 1
                    #output("step = ", step)
                    if step == math.log(k, 2) + 1:
                        elected = True
                        #output("elected")
                    else:
                        Received = True

    # ACK(id)
    def receive(msg=('ACK', node), from_= sender):
        receiving_flag = True
        #output("received ACK " , state, phase)
        if (state == 'candidate' and phase == 1 and node == self):
            Response = Response + 1
            if (Response == (n / k) - 1):
                phase = 2

    # ELECTED(id)
    def receive(msg=('ELECTED', node), from_= sender):
        receiving_flag = True
        #output("received ELECTED " , state, phase)
        if state == 'candidate':
            state = 'captured'
            leaderid = node

        elif (state == 'captured'):
            done = True
            leaderid = node

    # INFORM(x)
    def receive(msg=('INFORM', x), from_= sender):
        receiving_flag = True
        #output("received INFORM (", x, ")" "from", sender, ")", state, phase)
        if (state == 'candidate' and phase == 2):
            e = hCycle.index(sender)
            send(('CAPTURE', 2, step, self), to=hCycle[int((e + x) % n)])
            #output("send CAPTURE to(", hCycle[int((e + x) % n)], ")", 2, step)

    # OWNER(x)
    def receive(msg=('OWNER', node), from_= sender):
        receiving_flag = True
        #output("received OWNER " , state, phase)
        if (state == 'captured' and phase == 1):
            owner = hCycle.index(node)
            phase = 2
            send(('ACK', node), to=sender)
        elif (state == 'candidate' and phase == 1 and self == node):
            owner = hCycle.index(node)
            send(('ACK', node), to=sender)

    def run():
        #output("n = ", n)
        #output("k = ", k)
        if state == 'candidate':
            #output("be candidate")
            candidateAct()
        
        if (state == 'captured' and leaderid == None):
            #output("be captured")
            capturedAct()

        output("Leader is", leaderid)


def main():
    n = int(sys.argv[1]) if len(sys.argv) > 1 else 16
    config(channel="fifo")
    ps = list(new(P, num= n))
    output(ps)
    for i, p in enumerate(ps):
        setup({p}, ([ps[int((i+j) % n)] for j in range(n)],))
    start(ps)
